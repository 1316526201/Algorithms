第一章绪论
1.1 算法的5个基本特征：有穷性，确定性，输入,输出，可行性
1.2 算法的描述形式：伪语言说明
	以插入排序为例：
	Insert-sort(A)
1 	for j<- 2 to length[A]
2 	do key<- A[j]
	►A[j]插入到已排好序的子数组A[1..j-1]中
3 	i <-j-1
4 	while i>0 and A[i]>key
5 	do A[i+1] <-A[i]
6 	i<- i-1
7		A[i+1]<- key

1.3 算法分析：时间复杂度分析，空间复杂度分析

	传统分析方法来分析此排序算法时间复杂度：∑(指令执行一次的时间*一条指令执行的次数)
	
	其中： Ci表示每条指令一次执行的时间  tj表示j第次循环while语句执行的次数
	指令执行时间   执行次数
	c1							n           2到n+1  一共n次
	c2							n-1
	c3							n-1
	c4							∑tj  (j=2 ->n)
	c5							∑(tj-1) (j=2 ->n)
	c6							∑(tj-1) (j=2 ->n)
	c7							n-1
	
	
Tn=c1*n+c2*(n-1)+...c7*(n-1)
最好情况：输入数据状态为升序，此时A[i]≤key，所以tj=1T(n) = C1n+C2(n-1)+C3(n-1)+C4(n-1)+C7(n-1)
= (C1+C2+C3+C4+C7)n-(C2+C3+C4+C7)
= An+B

坏情况：输入数据状态为倒序，此时A[i]>key，所以tj=j
T(n) = C1n+C2(n-1)+C3(n-1)+C4
= ½(C4+C5+C6)n2+(C1+C2+C3+½C4-½C5
-½C6+C7)n-(C2+C3+C4+C7)
= An2+Bn+C


平均情况：
是指在不同的输入条件下算法平均的运行时间。直观分析：插入A[j]时需比较j/2次， 即tj=j/2所以T(n)应和n2相关。
对于三种情况下算法的时间复杂度， 通常会更多地关注最坏情况下的时间复杂度， 原因为:
①是算法运行时间的上限， 也是算法改进的一个判断标准
②在很多时间问题中， 由于缺少足够的信息， 因此算法往往运行在最坏请况
③算法的平均情况下的时间往往与最坏情况下的时间复杂度相同

.5 增长速率(order of growth)
一个算法的时间是由其增长速率所决定的， 所以对于算法时间复杂度的研究主要侧重的是算法的渐进性能， 即当问题的输入规模n很大时算法的运行效率。
对于一个多项式时间的算法， 如： T(n) = An2+Bn+C,当n很大时， T(n)的增长速率是由最高项n2所决定。


1.6 算法正确性分析

循环不变式：正确算法的循环过程中总是存在一个维持不变的特性，这个特性一直保持到循环结束乃至算法结束
在插入排序中，算法每次循环后，前n个数一定是排好序的（n为已经循环的次数）。由于这个特性一直成立，到算法结束时，所有N个数一定是排好序的。


循环不变式(loop Invariant)方法:先确定算法的循环不变式， 然后检查此循环不变式在算法执行期间是否满足以下三个条件：
①初始状态(Initialization):循环前循环不变式为真
②保持状态(Maintance):如果本次循环前循环不变式为真， 则本次循环后依然为真
③终止状态(Termination):退出循环时， 循环不变式为真

例:插入排序算法的正确性分析：
循环不变式为：子数组A[1..j-1]始终为排好序的状态
① 初始状态(Initialization):
∵ 循环开始前j=2
∴ 进入循环前子数组A[1..j-1]只有一个元素， 此时
子数组为排好序的状态② 保持状态(Maintance):
∵ while循环前i=j-1， 若子数组A[1..i]=A[1..j-1]为
真， 循环开始时， 插入排序的过程是依次后移A[j-1]、
A[j-2]、 …并把新的关键字插入到合适的位置， 此时
子数组A[1..j-1]扩充为A[1..j]且为排好序的状态
∴ j++后循环不变式A[1..j-1]为真
③ 终止状态(Termination):退出循环时，
∵ j=n+1,此时子数组A[1..j-1]=A[1..n]包含所有元素
且为排好序的状态
∴ 循环不变式为真

